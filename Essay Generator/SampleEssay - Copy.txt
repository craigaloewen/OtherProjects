To calculate the highest and lowest elevations, or the local maximum and minimums, the partial derivatives of the elevation function with respect to x, and y need to be calculated first. The mesh approach that has been used in the prior questions cannot be used to evaluate the partial derivatives of the function. This is because the mesh uses large arrays to store the function values, and the best value of a derivative that could be obtained would be an interpolation between the known points. Therefore, a MatLab toolkit was used, where MatLab can calculate derivatives and solve for the roots. Instead of defining x and y as a mesh, they were defined as variables and then the differentiation function, diff(), was used to calculate the partial derivative for x, and y, and all associated second partial derivatives.
Next the elevation functions partials with respect to x and y would both need to be equal to 0 for there to be a critical point. This process was more difficult to do, because to find a critical point first a guess has to be inputted. This means that it is necessary to analyze the plot in part a) and determine a point that is close to a critical point, and then use this critical point in the algorithm.
This was made more challenging due to the fact that the slope is close to flat near the edges of the boundary, which means that any inputted guess that is close to the edge of the shape will make the algorithm result in determining that that is a critical point. 
Three critical points were identified. By contrasting these points to the plots in 1 a), it is clear that these are valid maximum and minimum areas, instead of the simply flat areas that dominate the outside of the terrain. These flat values have a D value of 0, and so were not included as critical points in this table.
Once the critical points were determined, it was simple to input their values into the D=B2-AC equation and determine what kind of critical point they were. The next step was to determine whether they were local maximum, minimums or saddle points which can be accomplished using the value of D and A. A negative value of D indicates a local maximum or minimum, and if the value of A is negative it is a minimum, else it is a maximum. Lastly, these points were identified as absolute or local maximum or minimums based off of the 3D plot in 1 a). The code to accomplish this can be seen in Appendix A, and the results can be seen in the Summary of Results section. 

To determine if the hiker would be ascending or descending, the concept of directional derivatives was used. At its core, if the dot product of the direction that the hiker is walking in, and the directional derivative of the elevation function is a positive value then the hiker is ascending, if it is zero then the hiker’s elevation is not changing, and otherwise the hiker is descending. The first step inside of MatLab was to create the direction of North West, and make this a unit vector. Assuming x is East and West, and Y is the North and South directions, North West would correspond to the unit vector

which has a length of one so that it does not alter the magnitude of the result of the dot product. Next, the partial derivatives of the elevation are taken in terms of x and y. These are already expressed inside of a function, and the values are elevated at the starting point of the hiker. Then these are placed into a vector, and the dot product of the unit direction vector and the directional derivative are taken. The change in slope of the elevation is positive and therefore, the hiker would be ascending.

An identical process was used to evaluate the rate of change in temperature that the hiker would experience as she walks in the North West direction. Instead of using the elevation function in terms of x, and y, the temperature function was used in terms of x, and y. This is because the hiker will be walking on the terrain, and so the z value inside of the temperature function can be substituted with its equation in terms of x, and y. The partial derivatives with respect to x, and y were found, and made into a function, so that they could be evaluated at any x or y value. Then its values at x=4, and y=-0.3 were found, and made into a vector. The dot product of this directional derivative and the direction of the hiker’s travel resulted in the rate of change of the temperature per kilometer travelled in the x and y plane. 

These plots were produced with the same process describe in question 1 a). This plot provides the value of the temperature with respect to the hiker’s x,y position. It differs from the plot in part e), as the z value on the 3D plot is the temperature instead of the elevation. While the plot in part e) shows the same information, this plot is more valuable in determining how the temperature changes over the xy plane, as the slope is easier to determine than in the plot in part e). This is valuable to the hiker, as it would allow her to determine how quickly the temperature changed with respect to their hiking route. Additionally, this graph easily demonstrates the isotherms at different points on the terrain, and this would be valuable in planning a route where the temperature does not change over the course of the hike. 

Then four partials of the LaGrangian function are taken, with respect to x,y,z, and lambda. These are taken as a system of equations, and are solved for when they are all equal to zero, which when solved will result in the desired output. As done earlier, first the functions were derived using the symbolic toolkit, and then were put into a MatLab function so that MatLab could solve the problem numerically. The initial guess for this function had to be very accurate, luckily the earlier graphs showing the temperature at each point of the terrain could be used to make an accurate guess. 


Producing bells is a complex process, and much of the knowledge on relating the sound produced to the design is based upon extensive experimentation, which is how the principles that the frequency varies to the square of the thickness, and inversely with the diameter. Traditionally, after casting the bell has to be filed down in sections to produce a quality note. The goal of this project was to use ANSYS as a means of determining the sound that would be produced by bells of variable shapes. 

Additionally, this technique can be applied to noise, vibration and harshness studies. By appropriately identifying how a part may vibrate under certain boundary conditions, it is possible to greatly reduce the noise it would produce. An example of this is many parts inside of an automobile, as ideally the vehicle should be as quite as possible when driving at higher speeds.


The purpose of this report is to demonstrate an understanding, and knowledge of different methods of filtering sound files. Specifically, this report will focus on three methods: average, weighted average, and median filtering. Firstly, the mathematical definitions, and explanations of how to implement the filters will be outlined. Secondly, the report will show the use of the filters in practice, on three different sound files that were provided, and demonstrate analysis on which of these low pass filters[1] works best to eliminate the noise present in each file. Lastly the report will provide a rationale of how an algorithm was developed to count the occurrences of certain sounds in each file.In Figure 3 it is easy to determine the noise, as the signal is obviously a sine wave, so the solution is known. It is more difficult to determine this noise with an unknown solution, as is the case in the sound files provided. Instead, a section of the signal can be chosen where the solution can be known or approximated, and then the peak to peak value of the noise at that section can be applied to the rest of the signal as the noise present. This process is easiest when the signal is supposed to be outputting no sound, and so the solution value is zero. Therefore to approximate the noise, first choose a length of sound where it is reasonably certain that no sounds should be playing, and use that section to approximate the noise function to obtain a peak to peak value. That peak to peak value can be applied to the rest of the signal, with the assumption that the noise is constant.

The figure below demonstrates a small section of the tapestry sound file, where no words are being spoken so we can assume that the solution at this section is supposed to be silent, or 0. It is easy to see that this file has the same noise that is present in Figure 3 above. This noise was decreased by smoothing the curve using an averaging filter. Therefore the noise that is present in the files is defined mathematically by the description above. The figure below shows a noticeable improvement due to the filtering on reducing the amplitude of the noise, or the peak to peak value. 

The second filter used was the weighted averaging filter with the minimum window size of 5. This was accomplished by convolving the signal with a triangular impulse wave as shown in section 2.2. The minimum window size for a triangular weighted average filter because any smaller window would effectively be a square wave. The end values of the triangular pulse are both zeros so a triangle wave of width 4 and height 1 would have the values (0, 0.5, 0.5, 0), which is effectively a square wave. The sound quality decreased when using a weighted averaging filter regardless of the window. The quality became worse as the signal size was increased.

Of the three filters applied, the averaging filter using a square wave was the most successful. However, the sound quality was reduced using all three signals. The square wave damages the signal the least because it has the smallest minimum window size.
Low pass filtering failed to improve the quality of the Clay Colored Robin signal because the sampling frequency is too low compared to the frequency of the sound signal. As mentioned above, the sampling frequency is only approximately four times the frequency of the bird chirping. If the sampling frequency were less than twice the frequency of the signal, the signal would be considered not well defined. Therefore the chirping sounds are approaching the upper bound of defined frequencies for this sampling frequency. Because of this, there are not many higher frequencies to filter out with a low pass filter.
The reason these three filters cause loss of sound quality is because they are averaging peaks with troughs of amplitude over the time domain. When the troughs and peaks are very close to each other due to a high frequency signal and a low sampling frequency, an average of adjacent points will often include points with positive and negative amplitude. This phenomenon is clearest in figure 11 where the median function causes points of very low amplitude where there was high amplitude in the unfiltered signal as seen in figure 10.
The effect is less pronounced in the square and triangle wave averaging functions. In these cases it can be seen as a decrease in overall amplitude of the signal. In this case the filter system is reducing the chirp as if it were noise.

The sampling frequency for the Drum Loop signal is 44 100 Hz. Because this sampling frequency is so high and drums produce a low frequency, the ideal filter windows were expected to be large for this signal.

To reduce noise in the signal an average filter, a weighted average filter and a median filter were applied as can be seen in figures 15, 16 and 17 respectively.

From analyzing figures 15-17, along with the audio quality of the filtered signal, the weighted average was selected as the best filter. The sound produced was the clearest and contained the least noise. The quality of this sound had significant improvement over the original unfiltered sound. 

In general, all the low pass filters were successful at improving the quality of the Drum Loop sound. However, the sound of the cymbals was much higher than the drums and began to degrade long before the sound of the drums. While the ideal window sizes for this signal were largest for drum loop, they could be dramatically bigger if the track contained only the sound of the drums.


The second part of the project was to determine the number of chirps in the Clay Colored Robin signal, the number of syllables in the Tapestry signal, and the beats per second in the DrumLoop1 signal. 

To accomplish this, an algorithm was developed. The goal was to keep it as general as possible so that it could be reused for each signal easily, and act more as a function than a specific algorithm. The first step is to filter the signal to remove the noise as best as possible, using the analysis shown in section 3. After that, the algorithm absolute values the filtered signal so that all values are positive. Next, the algorithm heavily filters this result, as it will resemble an absolute value of a sinusoid where it will contain values between 0 and the maximum amplitude. The heavy filtering is accomplished by repeatedly filtering with a large window size. The reason for a large window size is to eliminate the repeated 0 values, due to the oscillation of the input signal, even at high amplitudes. As well, this is repeated to make the curve smoother while still maintaining the original shape of the input signal. The figure below shows the results of our algorithm when it modifies a signal. The next step is to define a high and low threshold value. When the algorithm moves from a low value, and crosses a high value it will count that as a syllable. Similarly, when it moves from a high value and crosses down to a low value it will reset, and be ready to count again. The reason for there being a high value to turn it on, and a lower value to turn it off is that there is still some noise present in the modified signal, and if a single value was chosen it would result in many false positives as the modified signal oscillated above and below this value. Therefore, the trigger high and the trigger low values need to be larger than the noise present in the modified signal. Lastly, the algorithm outputs the number it counted.

This algorithm works under the assumption that everything above a certain amplitude value is a signal of interest, and everything below that value is considered as noise. That being said, this definition becomes a little more blurry when considering what defines a ‘chirp’, as there is a noticeable decrease in amplitude during the whistling chirp of the bird (which can be seen in the figure above). In the case of the definition presented by this report, a chirp is when sustained noise is being produced, therefore chirps are separated by blank noise. The high and low toggle values are chosen appropriately such that it only triggers at suitable values. The definition of the chirp can be changed by altering the high and low trigger values. A similar reasoning process was used to determine syllables and beats per second.

When analyzing the drum beats per minute, the algorithm was adjusted to only consider the middle of the wave file, where the beat was more consistent. Since the drum beat had jazzy elements at the beginning and end, which were irregular, this would have skewed the results of the algorithm. Only major drum beats were considered, while cymbals and high hat were ignored. This was done so that the beats per minute was representative of the time signature of the music rather than the number of percussive sounds divided by the time. 

Below is the output of the algorithm on calculating the specified values.


The first conclusion that can be drawn from the report is that all three signal filtering methods act as low pass filtering, and will serve to eliminate high frequency values from the signal. Therefore, when these techniques are applied to the Tapestry wave form, the quality does improve. This is because the recorded signal is of a human voice, which is less than the sampling frequency that was used to record the signal. Therefore when a low pass filter is applied, it can decrease the noise effectively without degrading the quality of the signal. As well, the weighted average seems to be the best method for creating a clearer signal as it is less influenced by noise farther from the point of interest.

The second conclusion is that all three filters in this report only serve to degrade the sound quality in the Clay Colored Robin signal. As mentioned above, these are all low pass filters. Since the recorded signal is of a bird chirp, which is a very high frequency, any low pass filter, even with the smallest window possible, will serve only to decrease the overall quality of the sound.

The last conclusion is that due to the nature of the Drum Loop file, the three filters provide mixed results. The drums have a very low frequency, meaning that a large window could be applied to them to significantly reduce noise. This is not possible, as the Drum Loop also contains cymbals, which are very high frequency, and therefore have the same problem as the Clay Colored Robin where low pass filters with a big window degrade their quality. Overall, from listening to the quality of the sound, the Drum Loop had the highest filtering window, as its signal frequency to sampling frequency ratio was the lowest.
This report was only concerning three low pass filters, and used them to attempt to increase the sound quality of three sound waves by reducing the noise present. This report concluded that in two out of the three files: Clay Colored Robin, and Drum Loop, there are frequencies present that are too high, and therefore any low pass filtering will degrade the overall sound quality. A solution to this would be to increase the sampling rate of the sound file, such that the sampling rate is two times the maximum frequency of the signal, which will allow some low pass filtering to be used.

Additionally, instead of only using low pass filters, it would improve the report if a high pass filter was included. Then the problem stated above of high frequency input signals would have another solution, as a high pass filter could be used on them without degrading sound quality. The drawback is that this would not eliminate the high frequency noise, but would eliminate low frequency background noise. 

Therefore, a general recommendation to make this report more successful in increasing the sound quality of the signal is to include a higher variety of available filters, with higher quality sound signals. 

